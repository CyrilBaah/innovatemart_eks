name: 'Deploy Infrastructure (Terraform)'

on:
  push:
    branches:
      - main
    paths:
      - 'terraform/**'
      - '.github/workflows/deploy-infrastructure.yml'
  
  pull_request:
    branches:
      - main
    paths:
      - 'terraform/**'
      - '.github/workflows/deploy-infrastructure.yml'
  
  workflow_dispatch:  # Allow manual trigger

env:
  TF_VERSION: '1.6.0'
  TERRAFORM_DIR: './terraform'
  STATE_BUCKET: 'bedrock-tfstate-alt-soe-025-0223'
  LOCK_TABLE: 'bedrock-terraform-state-lock'
  CLUSTER_NAME: 'project-bedrock-cluster'

permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  terraform-plan:
    name: 'Terraform Plan'
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request'
    
    defaults:
      run:
        working-directory: ${{ env.TERRAFORM_DIR }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Setup Terraform Backend
      run: |
        # Create S3 bucket for Terraform state if it doesn't exist
        aws s3api head-bucket --bucket "${{ env.STATE_BUCKET }}" 2>/dev/null || \
          aws s3api create-bucket --bucket "${{ env.STATE_BUCKET }}" --region ${{ secrets.AWS_REGION }}
        
        # Enable versioning
        aws s3api put-bucket-versioning --bucket "${{ env.STATE_BUCKET }}" \
          --versioning-configuration Status=Enabled
        
        # Enable encryption
        aws s3api put-bucket-encryption --bucket "${{ env.STATE_BUCKET }}" \
          --server-side-encryption-configuration '{
            "Rules": [{            git add .gitignore README.md terraform/ lambda/ .github/workflows/deploy-infrastructure.yml
            git commit -m "feat: add infrastructure deployment with Terraform and GitHub Actions"
            git push origin main
              "ApplyServerSideEncryptionByDefault": {
                "SSEAlgorithm": "AES256"
              },
              "BucketKeyEnabled": true
            }]
          }'
        
        # Block public access
        aws s3api put-public-access-block --bucket "${{ env.STATE_BUCKET }}" \
          --public-access-block-configuration \
          "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
        
        # Create DynamoDB table for state locking if it doesn't exist
        aws dynamodb describe-table --table-name "${{ env.LOCK_TABLE }}" --region ${{ secrets.AWS_REGION }} 2>/dev/null || \
          aws dynamodb create-table \
            --table-name "${{ env.LOCK_TABLE }}" \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region ${{ secrets.AWS_REGION }} \
            --tags Key=Project,Value=Bedrock Key=ManagedBy,Value=Terraform
    
    - name: Terraform Format Check
      run: terraform fmt -check -recursive
      continue-on-error: false
    
    - name: Terraform Init
      run: terraform init
    
    - name: Terraform Validate
      run: terraform validate
    
    - name: Terraform Plan
      id: plan
      run: |
        terraform plan -no-color -out=tfplan
        terraform show -no-color tfplan > plan.txt
      continue-on-error: false
    
    - name: Comment Plan on PR
      uses: actions/github-script@v7
      if: github.event_name == 'pull_request'
      with:
        script: |
          const fs = require('fs');
          const plan = fs.readFileSync('terraform/plan.txt', 'utf8');
          const maxGitHubBodyCharacters = 65536;
          
          function chunkSubstr(str, size) {
            const numChunks = Math.ceil(str.length / size)
            const chunks = new Array(numChunks)
            for (let i = 0, o = 0; i < numChunks; ++i, o += size) {
              chunks[i] = str.substr(o, size)
            }
            return chunks
          }
          
          // Split the Terraform plan into chunks if it's too big
          var plans = chunkSubstr(plan, maxGitHubBodyCharacters); 
          for (let i = 0; i < plans.length; i++) {
            const output = `### Terraform Plan Output (Part ${i + 1} of ${plans.length})
            
            \`\`\`terraform
            ${plans[i]}
            \`\`\`
            
            **Branch:** ${{ github.head_ref }}
            **Triggered by:** @${{ github.actor }}
            
            *Review the plan carefully before merging to main.*
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: output
            });
          }

  terraform-apply:
    name: 'Terraform Apply'
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && (github.event_name == 'push' || github.event_name == 'workflow_dispatch')
    
    defaults:
      run:
        working-directory: ${{ env.TERRAFORM_DIR }}
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TF_VERSION }}
        terraform_wrapper: false
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Setup Terraform Backend
      run: |
        echo "Setting up Terraform backend (S3 + DynamoDB)..."
        
        # Create S3 bucket for Terraform state if it doesn't exist
        if aws s3api head-bucket --bucket "${{ env.STATE_BUCKET }}" 2>/dev/null; then
          echo "S3 bucket already exists"
        else
          echo "Creating S3 bucket..."
          if [ "${{ secrets.AWS_REGION }}" = "us-east-1" ]; then
            aws s3api create-bucket --bucket "${{ env.STATE_BUCKET }}" --region ${{ secrets.AWS_REGION }}
          else
            aws s3api create-bucket --bucket "${{ env.STATE_BUCKET }}" --region ${{ secrets.AWS_REGION }} \
              --create-bucket-configuration LocationConstraint=${{ secrets.AWS_REGION }}
          fi
        fi
        
        # Enable versioning
        echo "Enabling versioning..."
        aws s3api put-bucket-versioning --bucket "${{ env.STATE_BUCKET }}" \
          --versioning-configuration Status=Enabled
        
        # Enable encryption
        echo "Enabling encryption..."
        aws s3api put-bucket-encryption --bucket "${{ env.STATE_BUCKET }}" \
          --server-side-encryption-configuration '{
            "Rules": [{
              "ApplyServerSideEncryptionByDefault": {
                "SSEAlgorithm": "AES256"
              },
              "BucketKeyEnabled": true
            }]
          }'
        
        # Block public access
        echo "Blocking public access..."
        aws s3api put-public-access-block --bucket "${{ env.STATE_BUCKET }}" \
          --public-access-block-configuration \
          "BlockPublicAcls=true,IgnorePublicAcls=true,BlockPublicPolicy=true,RestrictPublicBuckets=true"
        
        # Create DynamoDB table for state locking if it doesn't exist
        if aws dynamodb describe-table --table-name "${{ env.LOCK_TABLE }}" --region ${{ secrets.AWS_REGION }} 2>/dev/null; then
          echo "DynamoDB table already exists"
        else
          echo "Creating DynamoDB table for state locking..."
          aws dynamodb create-table \
            --table-name "${{ env.LOCK_TABLE }}" \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region ${{ secrets.AWS_REGION }} \
            --tags Key=Project,Value=Bedrock Key=ManagedBy,Value=Terraform
          
          echo "Waiting for DynamoDB table to be active..."
          aws dynamodb wait table-exists --table-name "${{ env.LOCK_TABLE }}" --region ${{ secrets.AWS_REGION }}
          echo "DynamoDB table is ready"
        fi
        
        echo "Backend setup complete!"
    
    - name: Terraform Init
      run: |
        echo "Initializing Terraform..."
        terraform init
    
    - name: Terraform Apply
      run: |
        echo "Deploying infrastructure..."
        terraform apply -auto-approve
      continue-on-error: false
    
    - name: Deployment Summary
      if: success()
      run: |
        echo "Infrastructure deployment completed successfully!"
        echo ""
        echo "Deployment Details:"
        echo "========================================================"
        terraform output
        echo "========================================================"
        echo ""
        echo "Next steps:"
        echo "1. Review the infrastructure outputs above"
        echo "2. Deploy the application using the 'Deploy Application' workflow"
        echo "3. Verify resources in AWS Console"
