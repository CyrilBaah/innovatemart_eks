name: 'Deploy Application (Kubernetes)'

on:
  push:
    branches:
      - main
    paths:
      - 'k8s-manifests/**'
      - '.github/workflows/deploy-application.yml'
  
  workflow_dispatch:  # Allow manual trigger

env:
  CLUSTER_NAME: 'project-bedrock-cluster'
  APP_NAMESPACE: 'retail-app'

permissions:
  contents: read

jobs:
  deploy-application:
    name: 'Deploy Retail Store Application'
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.30.0'
    
    - name: Setup Helm
      uses: azure/setup-helm@v3
      with:
        version: '3.12.0'
    
    - name: Verify EKS Cluster Exists
      id: check-cluster
      run: |
        echo "üîç Checking if EKS cluster exists..."
        if aws eks describe-cluster --name ${{ env.CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} > /dev/null 2>&1; then
          echo "‚úÖ EKS cluster '${{ env.CLUSTER_NAME }}' found"
          
          # Check cluster status
          CLUSTER_STATUS=$(aws eks describe-cluster --name ${{ env.CLUSTER_NAME }} --region ${{ secrets.AWS_REGION }} --query 'cluster.status' --output text)
          if [ "$CLUSTER_STATUS" = "ACTIVE" ]; then
            echo "‚úÖ Cluster is ACTIVE and ready"
            echo "cluster_exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Cluster status: $CLUSTER_STATUS (not ACTIVE)"
            echo "::warning::Cluster exists but may not be ready. Status: $CLUSTER_STATUS"
            echo "cluster_exists=true" >> $GITHUB_OUTPUT
          fi
        else
          echo "‚ùå EKS cluster '${{ env.CLUSTER_NAME }}' not found"
          echo "cluster_exists=false" >> $GITHUB_OUTPUT
          echo "::error::EKS cluster does not exist. Please run the 'Deploy Infrastructure' workflow first."
          exit 1
        fi
    
    - name: Update kubeconfig
      if: steps.check-cluster.outputs.cluster_exists == 'true'
      run: |
        echo "üîß Updating kubeconfig for cluster access..."
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
        echo "‚úÖ Kubeconfig updated"
    
    - name: Verify cluster connectivity
      run: |
        echo "üîó Testing cluster connectivity..."
        kubectl cluster-info
        kubectl get nodes
        echo "‚úÖ Cluster is accessible"
    
    - name: Create application namespace
      run: |
        echo "üì¶ Creating namespace '${{ env.APP_NAMESPACE }}'..."
        kubectl apply -f k8s-manifests/namespace.yaml
        echo "‚úÖ Namespace ready"
    
    - name: Add Helm repositories
      run: |
        echo "üìö Adding Helm repositories..."
        helm repo add bitnami https://charts.bitnami.com/bitnami
        helm repo update
        echo "‚úÖ Helm repositories updated"
    
    - name: Deploy AWS Retail Store Sample Application using Kubernetes manifests
      run: |
        echo "üöÄ Deploying complete retail store application to namespace '${{ env.APP_NAMESPACE }}'..."
        
        # Download the official Kubernetes manifests and apply directly to our namespace
        kubectl apply -f https://github.com/aws-containers/retail-store-sample-app/releases/latest/download/kubernetes.yaml -n ${{ env.APP_NAMESPACE }}
        
        echo "‚úÖ Retail store application deployed successfully"
    
    - name: Wait for all deployments to be ready
      run: |
        echo "‚è≥ Waiting for all deployments to be ready..."
        
        # Wait for all main application deployments
        deployments=("ui" "catalog" "cart" "orders" "checkout" "assets")
        for deployment in "${deployments[@]}"; do
          echo "‚è≥ Waiting for deployment/$deployment..."
          kubectl wait --for=condition=available --timeout=600s deployment/$deployment -n ${{ env.APP_NAMESPACE }} || true
        done
        
        # Wait for database deployments
        echo "‚è≥ Waiting for database deployments..."
        kubectl wait --for=condition=available --timeout=600s deployment -l app.kubernetes.io/component=primary -n ${{ env.APP_NAMESPACE }} || true
        
        echo "‚úÖ All deployments processed"
    
    - name: Get deployment status
      run: |
        echo "üìä Deployment Status:"
        echo ""
        echo "=== All Pods ==="
        kubectl get pods -n ${{ env.APP_NAMESPACE }} -o wide
        echo ""
        echo "=== Services ==="
        kubectl get services -n ${{ env.APP_NAMESPACE }} -o wide
        echo ""
        echo "=== Deployments ==="
        kubectl get deployments -n ${{ env.APP_NAMESPACE }}
        echo ""
        echo "=== Persistent Volume Claims ==="
        kubectl get pvc -n ${{ env.APP_NAMESPACE }}
    
    - name: Get application URL
      run: |
        echo "üåê Getting application URL..."
        echo ""
        echo "Waiting for LoadBalancer to be provisioned (this may take a few minutes)..."
        
        # Wait up to 10 minutes for the LoadBalancer to get an external IP
        for i in {1..60}; do
          LB_URL=$(kubectl get svc ui -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
          if [ -n "$LB_URL" ]; then
            echo "‚úÖ Application is accessible at: http://$LB_URL"
            echo ""
            echo "===================================="
            echo "üéâ Retail Store Application Deployed!"
            echo "===================================="
            echo "Frontend URL: http://$LB_URL"
            echo "Namespace: ${{ env.APP_NAMESPACE }}"
            echo "Environment: production"
            echo ""
            echo "Services deployed:"
            echo "- üåê Frontend (UI)"
            echo "- üìö Catalog Service"
            echo "- üõí Cart Service" 
            echo "- üìã Orders Service"
            echo "- üí≥ Checkout Service"
            echo "- üìÅ Assets Service"
            echo "- üóÑÔ∏è MySQL (Catalog DB)"
            echo "- üóÑÔ∏è PostgreSQL (Orders DB)"
            echo "- üî¥ Redis (Cache)"
            echo "- üê∞ RabbitMQ (Messaging)"
            echo "===================================="
            break
          fi
          echo "‚è≥ Waiting for LoadBalancer... (attempt $i/60)"
          sleep 10
        done
        
        if [ -z "$LB_URL" ]; then
          echo "‚ö†Ô∏è LoadBalancer URL not available yet. The application is still starting up."
          echo "Check later with: kubectl get svc ui -n ${{ env.APP_NAMESPACE }}"
          echo ""
          echo "You can also access the application using port-forward:"
          echo "kubectl port-forward svc/ui 8080:80 -n ${{ env.APP_NAMESPACE }}"
          echo "Then visit: http://localhost:8080"
        fi
    
    - name: Deployment Summary
      if: always()
      run: |
        echo ""
        echo "===================================="
        echo "üìã AWS Retail Store Deployment Summary"
        echo "===================================="
        echo "Cluster: ${{ env.CLUSTER_NAME }}"
        echo "Namespace: ${{ env.APP_NAMESPACE }}"
        echo "Environment: production"
        echo ""
        echo "üîç To monitor and manage your application:"
        echo ""
        echo "1. Get the application URL:"
        echo "   kubectl get svc ui -n ${{ env.APP_NAMESPACE }}"
        echo ""
        echo "2. View all application components:"
        echo "   kubectl get all -n ${{ env.APP_NAMESPACE }}"
        echo ""
        echo "3. Check individual service logs:"
        echo "   kubectl logs -f deployment/ui -n ${{ env.APP_NAMESPACE }}      # Frontend"
        echo "   kubectl logs -f deployment/catalog -n ${{ env.APP_NAMESPACE }} # Catalog API"
        echo "   kubectl logs -f deployment/cart -n ${{ env.APP_NAMESPACE }}    # Cart API"
        echo "   kubectl logs -f deployment/orders -n ${{ env.APP_NAMESPACE }}  # Orders API"
        echo ""
        echo "4. Access the application locally (if LoadBalancer is not ready):"
        echo "   kubectl port-forward svc/ui 8080:80 -n ${{ env.APP_NAMESPACE }}"
        echo "   Then visit: http://localhost:8080"
        echo ""
        echo "5. Check database connections:"
        echo "   kubectl get pods -l app.kubernetes.io/component=primary -n ${{ env.APP_NAMESPACE }}"
        echo ""
        echo "===================================="

  validate-deployment:
    name: 'Validate Deployment'
    runs-on: ubuntu-latest
    needs: deploy-application
    if: success()
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ secrets.AWS_REGION }}
    
    - name: Setup kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'v1.30.0'
    
    - name: Update kubeconfig
      run: |
        aws eks update-kubeconfig --region ${{ secrets.AWS_REGION }} --name ${{ env.CLUSTER_NAME }}
    
    - name: Run health checks
      run: |
        echo "üè• Running comprehensive health checks for retail store application..."
        echo ""
        
        # Check if all main application pods are running
        services=("ui" "catalog" "carts" "orders" "checkout")
        failed_services=()
        
        for service in "${services[@]}"; do
          echo "üîç Checking $service service..."
          POD_STATUS=$(kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app.kubernetes.io/name=$service -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "NotFound")
          if [ "$POD_STATUS" == "Running" ]; then
            echo "‚úÖ $service is running"
          else
            echo "‚ùå $service status: $POD_STATUS"
            failed_services+=($service)
          fi
        done
        
        # Check database pods using different label selectors
        echo ""
        echo "üóÑÔ∏è Checking database services..."
        
        # Check MySQL (catalog database) 
        MYSQL_STATUS=$(kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app.kubernetes.io/name=catalog,app.kubernetes.io/component=mysql -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "NotFound")
        if [ "$MYSQL_STATUS" == "Running" ]; then
          echo "‚úÖ MySQL (catalog database) is running"
        else
          echo "‚ùå MySQL status: $MYSQL_STATUS"
          failed_services+=("mysql")
        fi
        
        # Check PostgreSQL (orders database)  
        POSTGRES_STATUS=$(kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app.kubernetes.io/name=orders,app.kubernetes.io/component=postgresql -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "NotFound")
        if [ "$POSTGRES_STATUS" == "Running" ]; then
          echo "‚úÖ PostgreSQL (orders database) is running"
        else
          echo "‚ùå PostgreSQL status: $POSTGRES_STATUS"
          failed_services+=("postgresql")
        fi
        
        # Check Redis
        REDIS_STATUS=$(kubectl get pods -n ${{ env.APP_NAMESPACE }} -l app.kubernetes.io/name=checkout,app.kubernetes.io/component=redis -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo "NotFound")
        if [ "$REDIS_STATUS" == "Running" ]; then
          echo "‚úÖ Redis is running"
        else
          echo "‚ùå Redis status: $REDIS_STATUS"
          failed_services+=("redis")
        fi
        
        # Check if UI service has endpoints (main application entry point)
        echo ""
        echo "üîó Checking service connectivity..."
        ENDPOINTS=$(kubectl get endpoints ui -n ${{ env.APP_NAMESPACE }} -o jsonpath='{.subsets[*].addresses[*].ip}' 2>/dev/null || echo "")
        if [ -n "$ENDPOINTS" ]; then
          echo "‚úÖ UI service has endpoints: $ENDPOINTS"
        else
          echo "‚ùå UI service has no endpoints"
          failed_services+=("ui-endpoints")
        fi
        
        # Summary
        echo ""
        if [ ${#failed_services[@]} -eq 0 ]; then
          echo "‚úÖ All health checks passed! Retail store application is fully operational."
        else
          echo "‚ùå Health check failures detected:"
          for failed in "${failed_services[@]}"; do
            echo "  - $failed"
          done
          echo ""
          echo "‚ÑπÔ∏è  Some services may still be starting up. Check pod status with:"
          echo "kubectl get pods -n ${{ env.APP_NAMESPACE }}"
          echo ""
          echo "üîç For troubleshooting, try:"
          echo "kubectl get all -n ${{ env.APP_NAMESPACE }}"
          echo "kubectl describe pods -n ${{ env.APP_NAMESPACE }}"
          
          # Don't fail the workflow if some services are still starting
          # exit 1
        fi
